1;461;2;) data_dict = pos . data_dict data_dict [ "array" ] [ "phase" ] = "false" data_dict [ "volume" ] [ "phase" ] = "false" assert pos . target_utils . pos_bring_up ( data_dict = data_dict ) == True yield pos def teardown_function ( ) : logger . info ( "========== TEAR DOWN AFTER TEST =========" ) assert pos . target_utils . helper . check_system_memory ( ) == True if pos . client . ctrlr_list ( ) [ 1 ] is not None : assert pos . client . nvme_disconnect ( pos . target_utils . ss_temp_list ) == True assert pos . cli . list_array ( ) [ 0 ] == True array_list = list ( pos . cli . array_dict . keys ( ) ) if len ( array_list ) == 0 : logger . info ( "No array found in the config" ) else : for array in array_list : assert pos . cli . info_array ( array_name = array ) [ 0 ] == True if pos . cli . array_dict [ array ] . lower ( ) == "mounted" : assert pos . cli . unmount_array ( array_name = array ) [ 0 ] == True logger . info ( "==========================================" ) def teardown_module ( ) : logger . info ( "========= TEAR DOWN AFTER SESSION ========" ) pos . exit_handler ( expected = True ) def wt_test_multi_array_setup ( array_list : list ) : """<br>    Function to setup the Multi array test environment<br><br>    array_list : List of dict of array configuration.<br>    """ try : if pos . target_utils . helper . check_pos_exit ( ) == True : assert pos . target_utils . pos_bring_up ( data_dict = pos . data_dict ) == True assert pos . cli . reset_devel ( ) [ 0 ] == True assert pos . cli . scan_device ( ) [ 0 ] == True assert pos . cli . list_device ( ) [ 0 ] == True system_disks = pos . cli . system_disks for array in array_list : array_name = array [ "array_name" ] buffer_dev = array [ "buffer_dev" ] raid_type = array [ "raid_type" ] nr_data_drives = array [ "nr_data_drives" ] write_back = array [ "write_back" ] if len ( system_disks ) < ( nr_data_drives ) : pytest . skip ( f "Insufficient disk count {system_disks}. Required                                 minimum {nr_data_drives}" ) data_disk_list = [ system_disks . pop ( 0 ) for i in range ( nr_data_drives ) ] spare_disk_list = [ ] if raid_type . upper ( ) == "NORAID" : raid_type = "no-raid" assert ( pos . cli . create_array ( write_buffer = buffer_dev , data = data_disk_list , spare = spare_disk_list , raid_type = raid_type , array_name = array_name , ) [ 0 ] == True ) assert ( pos . cli . mount_array ( array_name = array_name , write_back = write_back ) [ 0 ] == True ) return True except Exception as e : logger . error ( f "Test setup failed due to {e}" ) traceback . print_exc ( ) return False 
2;396;2;@ pytest . fixture ( scope = "session" , autouse = True ) def setup_module ( ) : global pos , raid_type , data_dict , data_store pos = POS ( ) data_store = { } data_dict = pos . data_dict data_dict [ "array" ] [ "phase" ] = "false" data_dict [ "volume" ] [ "phase" ] = "false" assert pos . target_utils . pos_bring_up ( data_dict = data_dict ) == True assert pos . cli . reset_devel ( ) [ 0 ] == True yield pos def teardown_function ( ) : logger . info ( "========== TEAR DOWN AFTER TEST =========" ) assert pos . target_utils . helper . check_system_memory ( ) == True if pos . client . ctrlr_list ( ) [ 1 ] is not None : assert pos . client . nvme_disconnect ( pos . target_utils . ss_temp_list ) == True assert pos . cli . list_array ( ) [ 0 ] == True array_list = list ( pos . cli . array_dict . keys ( ) ) if len ( array_list ) == 0 : logger . info ( "No array found in the config" ) else : for array in array_list : assert pos . cli . info_array ( array_name = array ) [ 0 ] == True if pos . cli . array_dict [ array ] . lower ( ) == "mounted" : assert pos . cli . unmount_array ( array_name = array ) [ 0 ] == True assert pos . cli . reset_devel ( ) [ 0 ] == True assert pos . target_utils . pci_rescan ( ) == True logger . info ( "==========================================" ) def teardown_module ( ) : logger . info ( "========= TEAR DOWN AFTER SESSION ========" ) pos . exit_handler ( expected = True ) raid = { "RAID0" : { "spare" : 0 , "data" : 2 } , "RAID10" : { "spare" : 2 , "data" : 2 } , "no-raid" : { "spare" : 0 , "data" : 1 } , "RAID5" : { "spare" : 1 , "data" : 3 } , } @ pytest . mark . sanity @ pytest . mark . parametrize ( "writeback" , [ True , False ] ) @ pytest . mark . parametrize ( "raid_type" , list ( raid . keys ( ) ) ) @ pytest . mark . parametrize ( "numvol" , [ 1 , 256 ] ) @ pytest . mark . parametrize ( 
3;310;2;) try : if pos . target_utils . helper . check_pos_exit ( ) == True : assert pos . target_utils . pos_bring_up ( data_dict = pos . data_dict ) == True assert pos . cli . reset_devel ( ) [ 0 ] == True assert pos . cli . scan_device ( ) [ 0 ] == True assert pos . cli . list_device ( ) [ 0 ] == True system_disks = pos . cli . system_disks if len ( system_disks ) < ( nr_data_drives + 1 ) : pytest . skip ( f "Insufficient disk count {system_disks}. Required minimum {nr_data_drives + 1}" ) data_disk_list = [ system_disks . pop ( 0 ) for i in range ( nr_data_drives ) ] array_name = "posarray1" assert ( pos . cli . create_array ( write_buffer = "uram0" , data = data_disk_list , spare = None , raid_type = raid_type , array_name = array_name , ) [ 0 ] == True ) assert pos . cli . mount_array ( array_name = array_name , write_back = False ) [ 0 ] == True assert ( pos . cli . create_volume ( "pos_vol_1" , array_name = array_name , size = "2000gb" ) [ 0 ] == True ) assert pos . target_utils . get_subsystems_list ( ) == True assert pos . cli . list_volume ( array_name = array_name ) [ 0 ] == True ss_list = [ ss for ss in pos . target_utils . ss_temp_list if "subsystem1" in ss ] assert ( pos . target_utils . mount_volume_multiple ( array_name = array_name , volume_list = pos . cli . vols , nqn_list = ss_list ) == True ) for ss in pos . target_utils . ss_temp_list : assert ( pos . client . nvme_connect ( ss , pos . target_utils . helper . ip_addr [ 0 ] , "1158" ) == True ) assert pos . client . nvme_list ( ) == True 
4;302;2;) if pos . target_utils . helper . check_pos_exit ( ) == True : assert pos . target_utils . pos_bring_up ( data_dict = pos . data_dict ) == True assert pos . cli . reset_devel ( ) [ 0 ] == True assert pos . target_utils . pci_rescan ( ) == True assert pos . cli . list_device ( ) [ 0 ] == True datalen = raid [ raid_type ] [ "data" ] sparelen = raid [ raid_type ] [ "spare" ] datalist = pos . cli . dev_type [ "SSD" ] [ 0 : datalen ] sparelist = [ ] if sparelen == 0 else pos . cli . dev_type [ "SSD" ] [ - sparelen : ] assert ( pos . cli . create_array ( array_name = "array1" , data = datalist , write_buffer = pos . cli . dev_type [ "NVRAM" ] [ 0 ] , raid_type = raid_type , spare = sparelist , ) [ 0 ] == True ) array2raid = random . choice ( list ( raid . keys ( ) ) ) datalen = raid [ array2raid ] [ "data" ] sparelen = raid [ array2raid ] [ "spare" ] assert ( pos . cli . autocreate_array ( array_name = "array2" , num_data = datalen , num_spare = sparelen , buffer_name = pos . cli . dev_type [ "NVRAM" ] [ 1 ] , raid = array2raid , ) [ 0 ] == True ) assert pos . cli . list_device ( ) [ 0 ] == True assert pos . target_utils . get_subsystems_list ( ) == True for index , array in enumerate ( [ "array1" , "array2" ] ) : assert ( pos . cli . mount_array ( array_name = array , write_back = writeback ) [ 0 ] == True ) 
5;288;2;import pytest from pos import POS import logger import random import time logger = logger . get_logger ( __name__ ) @ pytest . fixture ( scope = "session" , autouse = True ) def setup_module ( ) : global pos , data_dict pos = POS ( "wt_array.json" ) data_dict = pos . data_dict assert pos . target_utils . pos_bring_up ( data_dict = data_dict ) == True yield pos def teardown_function ( ) : logger . info ( "========== TEAR DOWN AFTER TEST =========" ) assert pos . target_utils . helper . check_system_memory ( ) == True if pos . client . ctrlr_list ( ) [ 1 ] is not None : assert pos . client . nvme_disconnect ( pos . target_utils . ss_temp_list ) == True assert pos . cli . list_array ( ) [ 0 ] == True array_list = list ( pos . cli . array_dict . keys ( ) ) if len ( array_list ) == 0 : logger . info ( "No array found in the config" ) else : for array in array_list : assert pos . cli . info_array ( array_name = array ) [ 0 ] == True if pos . cli . array_dict [ array ] . lower ( ) == "mounted" : assert pos . cli . unmount_array ( array_name = array ) [ 0 ] == True assert pos . cli . reset_devel ( ) [ 0 ] == True logger . info ( "==========================================" ) def teardown_module ( ) : logger . info ( "========= TEAR DOWN AFTER SESSION ========" ) pos . exit_handler ( expected = True ) @ pytest . mark . regression @ pytest . mark . parametrize ( "raid_type, nr_data_drives" , [ ( "no-raid" , 1 ) , ( "RAID0" , 2 ) , ( "RAID10" , 4 ) 
6;276;2;import pytest from pos import POS import logger import random import time logger = logger . get_logger ( __name__ ) @ pytest . fixture ( scope = "session" , autouse = True ) def setup_module ( ) : global pos , data_dict pos = POS ( "wt_array.json" ) data_dict = pos . data_dict assert pos . target_utils . pos_bring_up ( data_dict = data_dict ) == True yield pos def teardown_function ( ) : logger . info ( "========== TEAR DOWN AFTER TEST =========" ) assert pos . target_utils . helper . check_system_memory ( ) == True if pos . client . ctrlr_list ( ) [ 1 ] is not None : assert pos . client . nvme_disconnect ( pos . target_utils . ss_temp_list ) == True assert pos . cli . list_array ( ) [ 0 ] == True array_list = list ( pos . cli . array_dict . keys ( ) ) if len ( array_list ) == 0 : logger . info ( "No array found in the config" ) else : for array in array_list : assert pos . cli . info_array ( array_name = array ) [ 0 ] == True if pos . cli . array_dict [ array ] . lower ( ) == "mounted" : assert pos . cli . unmount_array ( array_name = array ) [ 0 ] == True assert pos . cli . reset_devel ( ) [ 0 ] == True logger . info ( "==========================================" ) def teardown_module ( ) : logger . info ( "========= TEAR DOWN AFTER SESSION ========" ) pos . exit_handler ( expected = True ) @ pytest . mark . regression @ pytest . mark . parametrize ( "raid_type, nr_data_drives" , [ ( "RAID0" , 2 ) 
7;272;4;import pytest from pos import POS import logger import random import time logger = logger . get_logger ( __name__ ) @ pytest . fixture ( scope = "session" , autouse = True ) def setup_module ( ) : global pos , data_dict pos = POS ( "wt_array.json" ) data_dict = pos . data_dict assert pos . target_utils . pos_bring_up ( data_dict = data_dict ) == True yield pos def teardown_function ( ) : logger . info ( "========== TEAR DOWN AFTER TEST =========" ) assert pos . target_utils . helper . check_system_memory ( ) == True if pos . client . ctrlr_list ( ) [ 1 ] is not None : assert pos . client . nvme_disconnect ( pos . target_utils . ss_temp_list ) == True assert pos . cli . list_array ( ) [ 0 ] == True array_list = list ( pos . cli . array_dict . keys ( ) ) if len ( array_list ) == 0 : logger . info ( "No array found in the config" ) else : for array in array_list : assert pos . cli . info_array ( array_name = array ) [ 0 ] == True if pos . cli . array_dict [ array ] . lower ( ) == "mounted" : assert pos . cli . unmount_array ( array_name = array ) [ 0 ] == True assert pos . cli . reset_devel ( ) [ 0 ] == True logger . info ( "==========================================" ) def teardown_module ( ) : logger . info ( "========= TEAR DOWN AFTER SESSION ========" ) pos . exit_handler ( expected = True ) @ pytest . mark . regression @ pytest . mark . parametrize ( "raid_type, nr_data_drives" , [ ( 
8;268;5;import pytest from pos import POS import logger import random import time logger = logger . get_logger ( __name__ ) @ pytest . fixture ( scope = "session" , autouse = True ) def setup_module ( ) : global pos , data_dict pos = POS ( "wt_array.json" ) data_dict = pos . data_dict assert pos . target_utils . pos_bring_up ( data_dict = data_dict ) == True yield pos def teardown_function ( ) : logger . info ( "========== TEAR DOWN AFTER TEST =========" ) assert pos . target_utils . helper . check_system_memory ( ) == True if pos . client . ctrlr_list ( ) [ 1 ] is not None : assert pos . client . nvme_disconnect ( pos . target_utils . ss_temp_list ) == True assert pos . cli . list_array ( ) [ 0 ] == True array_list = list ( pos . cli . array_dict . keys ( ) ) if len ( array_list ) == 0 : logger . info ( "No array found in the config" ) else : for array in array_list : assert pos . cli . info_array ( array_name = array ) [ 0 ] == True if pos . cli . array_dict [ array ] . lower ( ) == "mounted" : assert pos . cli . unmount_array ( array_name = array ) [ 0 ] == True assert pos . cli . reset_devel ( ) [ 0 ] == True logger . info ( "==========================================" ) def teardown_module ( ) : logger . info ( "========= TEAR DOWN AFTER SESSION ========" ) pos . exit_handler ( expected = True ) @ pytest . mark . regression @ pytest . mark . parametrize ( 
9;263;2;] phase_time = Time start_time = time . time ( ) assert ( libcore . subsystem_module ( target = target , client = client , data_set = data_set , config_dict = test_dict , action = "create" , phase = phase , ) == True ) logger . info ( "Lock status : acquire {}" . format ( target . cli . lock . acquire ( ) ) ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "create" , phase = phase , ) == True ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "mount" , phase = phase , ) == True ) logger . info ( "Lock status : release {}" . format ( target . cli . lock . release ( ) ) ) assert target . cli . list_volume ( target . cli . array_name ) [ 0 ] == True assert ( libcore . subsystem_module ( target = target , client = client , data_set = data_set , config_dict = test_dict , action = "connect" , phase = phase , ) == True ) time . sleep ( 5 ) model_name = test_dict [ "phase" ] [ 0 ] [ "volume" ] [ "create" ] [ "basename" ] assert client . nvme_list ( model_name ) == True fio_device = client . nvme_list_out current_time = time . time ( ) while True : logger . info ( "Lock status : acquire {}" . format ( target . cli . lock . acquire ( ) ) ) assert 
10;260;2;] phase_time = Time start_time = time . time ( ) assert ( libcore . subsystem_module ( target = target , client = client , data_set = data_set , config_dict = test_dict , action = "create" , phase = phase , ) == True ) logger . info ( "Lock status : acquire {}" . format ( target . cli . lock . acquire ( ) ) ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "create" , phase = phase , ) == True ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "mount" , phase = phase , ) == True ) logger . info ( "Lock status : release {}" . format ( target . cli . lock . release ( ) ) ) assert target . cli . list_volume ( target . cli . array_name ) [ 0 ] == True assert ( libcore . subsystem_module ( target = target , client = client , data_set = data_set , config_dict = test_dict , action = "connect" , phase = phase , ) == True ) time . sleep ( 5 ) model_name = test_dict [ "phase" ] [ 0 ] [ "volume" ] [ "create" ] [ "basename" ] assert client . nvme_list ( model_name ) == True fio_device = client . nvme_list_out current_time = time . time ( ) fio_time = phase_time - ( current_time - start_time ) if fio_time < 5 : fio_time = 10 while True : 
11;240;4;] phase_time = Time start_time = time . time ( ) assert ( libcore . subsystem_module ( target = target , client = client , data_set = data_set , config_dict = test_dict , action = "create" , phase = phase , ) == True ) logger . info ( "Lock status : acquire {}" . format ( target . cli . lock . acquire ( ) ) ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "create" , phase = phase , ) == True ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "mount" , phase = phase , ) == True ) logger . info ( "Lock status : release {}" . format ( target . cli . lock . release ( ) ) ) assert target . cli . list_volume ( target . cli . array_name ) [ 0 ] == True assert ( libcore . subsystem_module ( target = target , client = client , data_set = data_set , config_dict = test_dict , action = "connect" , phase = phase , ) == True ) time . sleep ( 5 ) model_name = test_dict [ "phase" ] [ 0 ] [ "volume" ] [ "create" ] [ "basename" ] assert client . nvme_list ( model_name ) == True fio_device = client . nvme_list_out current_time = time . time ( ) 
12;213;3;) data_dict = pos . data_dict data_dict [ "array" ] [ "phase" ] = "false" data_dict [ "volume" ] [ "phase" ] = "false" assert pos . target_utils . pos_bring_up ( data_dict = data_dict ) == True yield pos def teardown_function ( ) : logger . info ( "========== TEAR DOWN AFTER TEST =========" ) assert pos . target_utils . helper . check_system_memory ( ) == True if pos . client . ctrlr_list ( ) [ 1 ] is not None : assert pos . client . nvme_disconnect ( pos . target_utils . ss_temp_list ) == True assert pos . cli . list_array ( ) [ 0 ] == True array_list = list ( pos . cli . array_dict . keys ( ) ) if len ( array_list ) == 0 : logger . info ( "No array found in the config" ) else : for array in array_list : assert pos . cli . info_array ( array_name = array ) [ 0 ] == True if pos . cli . array_dict [ array ] . lower ( ) == "mounted" : assert pos . cli . unmount_array ( array_name = array ) [ 0 ] == True logger . info ( "==========================================" ) def teardown_module ( ) : logger . info ( "========= TEAR DOWN AFTER SESSION ========" ) pos . exit_handler ( expected = True ) 
13;201;5;] phase_time = Time start_time = time . time ( ) assert ( libcore . subsystem_module ( target = target , client = client , data_set = data_set , config_dict = test_dict , action = "create" , phase = phase , ) == True ) logger . info ( "Lock status : acquire {}" . format ( target . cli . lock . acquire ( ) ) ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "create" , phase = phase , ) == True ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "mount" , phase = phase , ) == True ) logger . info ( "Lock status : release {}" . format ( target . cli . lock . release ( ) ) ) assert target . cli . list_volume ( target . cli . array_name ) [ 0 ] == True assert ( libcore . subsystem_module ( target = target , client = client , data_set = data_set , config_dict = test_dict , action = "connect" , phase = phase , ) == True ) time . sleep ( 5 ) 
14;194;3;) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "create" , phase = phase , ) == True ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "mount" , phase = phase , ) == True ) logger . info ( "Lock status : release {}" . format ( target . cli . lock . release ( ) ) ) assert target . cli . list_volume ( target . cli . array_name ) [ 0 ] == True assert ( libcore . subsystem_module ( target = target , client = client , data_set = data_set , config_dict = test_dict , action = "connect" , phase = phase , ) == True ) time . sleep ( 5 ) model_name = test_dict [ "phase" ] [ 0 ] [ "volume" ] [ "create" ] [ "basename" ] assert client . nvme_list ( model_name ) == True fio_device = client . nvme_list_out current_time = time . time ( ) fio_time = phase_time - ( current_time - start_time ) if fio_time < 5 : fio_time = 10 
15;182;2;) [ 0 ] == True ) assert ( pos . cli . list_volume_policy_qos ( volumename = vol , arrayname = array ) [ 0 ] == True ) assert ( pos . target_utils . mount_volume_multiple ( array_name = array , volume_list = pos . cli . vols , nqn_list = [ pos . target_utils . ss_temp_list [ index ] ] , ) == True ) assert ( pos . client . nvme_connect ( pos . target_utils . ss_temp_list [ 0 ] , pos . target_utils . helper . ip_addr [ 0 ] , "1158" , ) == True ) assert pos . client . nvme_list ( ) == True assert ( pos . client . fio_generic_runner ( pos . client . nvme_list_out , fio_user_data = "fio --name=sequential_write --ioengine=libaio --rw=write --iodepth=64 --direct=1 --numjobs=1 --bs=128k --time_based --runtime=10" , ) [ 0 ] == True ) for vol in pos . cli . vols : assert ( pos . cli . reset_volume_policy_qos ( volumename = vol , arrayname = array ) [ 0 ] == True ) except Exception as e : logger . error ( e ) pos . exit_handler ( ) 
16;177;3;) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "create" , phase = phase , ) == True ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "mount" , phase = phase , ) == True ) logger . info ( "Lock status : release {}" . format ( target . cli . lock . release ( ) ) ) assert target . cli . list_volume ( target . cli . array_name ) [ 0 ] == True assert ( libcore . subsystem_module ( target = target , client = client , data_set = data_set , config_dict = test_dict , action = "connect" , phase = phase , ) == True ) time . sleep ( 5 ) model_name = test_dict [ "phase" ] [ 0 ] [ "volume" ] [ "create" ] [ "basename" ] assert client . nvme_list ( model_name ) == True fio_device = client . nvme_list_out current_time = time . time ( ) 
17;166;7;== True yield pos def teardown_function ( ) : logger . info ( "========== TEAR DOWN AFTER TEST =========" ) assert pos . target_utils . helper . check_system_memory ( ) == True if pos . client . ctrlr_list ( ) [ 1 ] is not None : assert pos . client . nvme_disconnect ( pos . target_utils . ss_temp_list ) == True assert pos . cli . list_array ( ) [ 0 ] == True array_list = list ( pos . cli . array_dict . keys ( ) ) if len ( array_list ) == 0 : logger . info ( "No array found in the config" ) else : for array in array_list : assert pos . cli . info_array ( array_name = array ) [ 0 ] == True if pos . cli . array_dict [ array ] . lower ( ) == "mounted" : assert pos . cli . unmount_array ( array_name = array ) [ 0 ] == True assert pos . cli . reset_devel ( ) [ 0 ] == True 
18;164;8;assert pos . target_utils . pos_bring_up ( data_dict = data_dict ) == True yield pos def teardown_function ( ) : logger . info ( "========== TEAR DOWN AFTER TEST =========" ) assert pos . target_utils . helper . check_system_memory ( ) == True if pos . client . ctrlr_list ( ) [ 1 ] is not None : assert pos . client . nvme_disconnect ( pos . target_utils . ss_temp_list ) == True assert pos . cli . list_array ( ) [ 0 ] == True array_list = list ( pos . cli . array_dict . keys ( ) ) if len ( array_list ) == 0 : logger . info ( "No array found in the config" ) else : for array in array_list : assert pos . cli . info_array ( array_name = array ) [ 0 ] == True if pos . cli . array_dict [ array ] . lower ( ) == "mounted" : assert pos . cli . unmount_array ( array_name = array ) [ 0 ] == True 
19;163;2;for dev_type in ( 'mix' , 'any' ) : device_types = [ dev_size for dev_size , dev_list in device_size_dict . items ( ) if dev_list ] device_count = sum ( len ( dev_list ) for dev_list in device_size_dict . values ( ) ) num_device = data_dev_select . get ( dev_type , 0 ) if ( num_device == 0 ) : continue if dev_type == 'mix' and len ( device_types ) < num_device : logger . error ( "Only {} device types are available. But {} are " "required." . format ( len ( device_types ) , num_device ) ) return False , selected_devices elif dev_type == 'any' and device_count < num_device : logger . error ( "Only {} devices are available. But {} are " "required." . format ( device_count , num_device ) ) return False , selected_devices counter = 0 while counter < num_device : for dev_type in device_size_dict . keys ( ) : if counter == num_device : break if device_size_dict [ dev_type ] : dev_name = device_size_dict [ dev_type ] . pop ( 0 ) selected_devices [ 
20;161;3;) try : if pos . target_utils . helper . check_pos_exit ( ) == True : assert pos . target_utils . pos_bring_up ( data_dict = pos . data_dict ) == True assert pos . cli . reset_devel ( ) [ 0 ] == True assert pos . cli . scan_device ( ) [ 0 ] == True assert pos . cli . list_device ( ) [ 0 ] == True system_disks = pos . cli . system_disks if len ( system_disks ) < ( nr_data_drives + 1 ) : pytest . skip ( f "Insufficient disk count {system_disks}. Required minimum {nr_data_drives + 1}" ) data_disk_list = [ system_disks . pop ( 0 ) for i in range ( nr_data_drives ) ] array_name = "posarray1" assert ( pos . cli . create_array ( write_buffer = "uram0" , data = data_disk_list , spare = None , raid_type = raid_type , array_name = array_name , ) [ 0 ] == True ) assert pos . cli . mount_array ( array_name = array_name 
21;153;5;== True yield pos def teardown_function ( ) : logger . info ( "========== TEAR DOWN AFTER TEST =========" ) assert pos . target_utils . helper . check_system_memory ( ) == True if pos . client . ctrlr_list ( ) [ 1 ] is not None : assert pos . client . nvme_disconnect ( pos . target_utils . ss_temp_list ) == True assert pos . cli . list_array ( ) [ 0 ] == True array_list = list ( pos . cli . array_dict . keys ( ) ) if len ( array_list ) == 0 : logger . info ( "No array found in the config" ) else : for array in array_list : assert pos . cli . info_array ( array_name = array ) [ 0 ] == True if pos . cli . array_dict [ array ] . lower ( ) == "mounted" : assert pos . cli . unmount_array ( array_name = array ) [ 0 ] == True 
22;141;2;arrayname = "array1" assert pos . cli . info_array ( array_name = arrayname ) [ 0 ] == True if raid_type not in [ "RAID0" , "no-raid" ] : disklist = [ random . choice ( pos . cli . dev_type [ "SSD" ] ) ] assert pos . target_utils . device_hot_remove ( disklist ) == True assert pos . target_utils . array_rebuild_wait ( array_name = arrayname ) == True assert pos . cli . info_array ( array_name = arrayname ) [ 0 ] == True assert pos . cli . unmount_array ( array_name = arrayname ) [ 0 ] == True assert pos . cli . delete_array ( array_name = arrayname ) [ 0 ] == True assert pos . cli . list_array ( ) [ 0 ] == True except Exception as e : logger . error ( f 
23;138;2;) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "create" , phase = phase , ) == True ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "mount" , phase = phase , ) == True ) logger . info ( "Lock status : release {}" . format ( target . cli . lock . release ( ) ) ) assert target . cli . list_volume ( target . cli . array_name ) [ 0 ] == True assert ( libcore . subsystem_module ( target = target , client = client , data_set = data_set , config_dict = test_dict , action = "connect" , phase = phase , ) == True ) time . sleep ( 5 ) 
24;132;2;) current_time = time . time ( ) running_time = current_time - start_time if running_time >= phase_time : break assert ( libcore . subsystem_module ( target = target , client = client , data_set = data_set , config_dict = test_dict , action = "disconnect" , phase = phase , ) == True ) logger . info ( "Lock status : acquire {}" . format ( target . cli . lock . acquire ( ) ) ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "unmount" , phase = phase , ) == True ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "delete" , phase = phase , ) == True ) 
25;130;2;) assert pos . target_utils . get_subsystems_list ( ) == True assert pos . cli . list_volume ( array_name = array_name ) [ 0 ] == True ss_temp_list = pos . target_utils . ss_temp_list ss_list = [ ss for ss in ss_temp_list if f "subsystem{id + 1}" in ss ] assert ( pos . target_utils . mount_volume_multiple ( array_name = array_name , volume_list = pos . cli . vols , nqn_list = ss_list ) == True ) for ss in pos . target_utils . ss_temp_list : assert ( pos . client . nvme_connect ( ss , pos . target_utils . helper . ip_addr [ 0 ] , "1158" ) == True ) assert pos . client . nvme_list ( ) == True nvme_devs = pos . client . nvme_list_out fio_cmd = f 
26;122;2;try : if pos . target_utils . helper . check_pos_exit ( ) == True : assert pos . target_utils . pos_bring_up ( data_dict = pos . data_dict ) == True assert pos . cli . reset_devel ( ) [ 0 ] == True assert pos . cli . scan_device ( ) [ 0 ] == True assert pos . cli . list_device ( ) [ 0 ] == True system_disks = pos . cli . system_disks if len ( system_disks ) < ( nr_data_drives + 1 ) : pytest . skip ( f "Insufficient disk count {system_disks}. Required minimum {nr_data_drives + 1}" ) assert pos . target_utils . get_subsystems_list ( ) == True ss_list = [ ss for ss in pos . target_utils . ss_temp_list if "subsystem" in ss ] 
27;108;11;yield pos def teardown_function ( ) : logger . info ( "========== TEAR DOWN AFTER TEST =========" ) assert pos . target_utils . helper . check_system_memory ( ) == True if pos . client . ctrlr_list ( ) [ 1 ] is not None : assert pos . client . nvme_disconnect ( pos . target_utils . ss_temp_list ) == True assert pos . cli . list_array ( ) [ 0 ] == True array_list = list ( pos . cli . array_dict . keys ( ) ) if len ( array_list ) == 0 : logger . info ( "No array found in the config" ) else : for array in array_list : assert pos . cli . 
28;108;2;== True ) assert pos . cli . list_volume ( array_name = array_name ) [ 0 ] == True assert ( pos . target_utils . mount_volume_multiple ( array_name = array_name , volume_list = pos . cli . vols , nqn_list = ss_list ) == True ) for ss in pos . target_utils . ss_temp_list : assert ( pos . client . nvme_connect ( ss , pos . target_utils . helper . ip_addr [ 0 ] , "1158" ) == True ) assert pos . client . nvme_list ( ) == True pos . client . check_system_memory ( ) nvme_devs = pos . client . nvme_list_out fio_cmd = f 
29;100;3;) [ 0 ] == True assert ( pos . cli . create_volume ( "pos_vol_1" , array_name = array_name , size = "2000gb" ) [ 0 ] == True ) assert pos . target_utils . get_subsystems_list ( ) == True assert pos . cli . list_volume ( array_name = array_name ) [ 0 ] == True ss_list = [ ss for ss in pos . target_utils . ss_temp_list if "subsystem1" in ss ] assert ( pos . target_utils . mount_volume_multiple ( array_name = array_name , volume_list = pos . cli . vols , nqn_list = ss_list ) == True ) 
30;96;11;assert pos . cli . list_array ( ) [ 0 ] == True array_list = list ( pos . cli . array_dict . keys ( ) ) if len ( array_list ) == 0 : logger . info ( "No array found in the config" ) else : for array in array_list : assert pos . cli . info_array ( array_name = array ) [ 0 ] == True if pos . cli . array_dict [ array ] . lower ( ) == "mounted" : assert pos . cli . unmount_array ( array_name = array ) [ 0 ] == True 
31;96;4;) try : if pos . target_utils . helper . check_pos_exit ( ) == True : assert pos . target_utils . pos_bring_up ( data_dict = pos . data_dict ) == True assert pos . cli . reset_devel ( ) [ 0 ] == True assert pos . cli . scan_device ( ) [ 0 ] == True assert pos . cli . list_device ( ) [ 0 ] == True system_disks = pos . cli . system_disks if len ( system_disks ) < ( nr_data_drives + 1 ) : pytest . skip ( f "Insufficient disk count {system_disks}. Required minimum {nr_data_drives + 1}" ) 
32;95;2;, ) [ 0 ] == True ) current_time = time . time ( ) running_time = current_time - start_time if running_time >= phase_time : break bs = test_dict [ "phase" ] [ phase ] [ "io" ] [ "fio" ] [ "bs" ] iod = test_dict [ "phase" ] [ phase ] [ "io" ] [ "fio" ] [ "iodepth" ] assert ( client . fio_generic_runner ( devices = fio_device , fio_user_data = ( "fio  --name=fio_read --rw=read --size={} --ioengine=libaio" " --direct=1 --iodepth={} --bs={} --numjobs=1 --offset=0" " --verify=pattern --verify_pattern={} --do_verify=1" " --continue_on_error=none" " --group_reporting" . format ( fio_size , iod , bs , pattern_data ) ) , json_out = 
33;95;4;try : if pos . target_utils . helper . check_pos_exit ( ) == True : assert pos . target_utils . pos_bring_up ( data_dict = pos . data_dict ) == True assert pos . cli . reset_devel ( ) [ 0 ] == True assert pos . cli . scan_device ( ) [ 0 ] == True assert pos . cli . list_device ( ) [ 0 ] == True system_disks = pos . cli . system_disks if len ( system_disks ) < ( nr_data_drives + 1 ) : pytest . skip ( f "Insufficient disk count {system_disks}. Required minimum {nr_data_drives + 1}" ) 
34;94;2;in ss ] assert ( pos . target_utils . mount_volume_multiple ( array_name = array_name , volume_list = pos . cli . vols , nqn_list = ss_list ) == True ) assert ( pos . client . nvme_connect ( ss_list [ 0 ] , pos . target_utils . helper . ip_addr [ 0 ] , "1158" ) == True ) assert pos . client . nvme_list ( ) == True dev = [ pos . client . nvme_list_out [ 0 ] ] assert pos . client . create_File_system ( dev , fs_format = "xfs" ) 
35;92;2;, phase = phase , ) == True ) logger . info ( "Lock status : acquire {}" . format ( target . cli . lock . acquire ( ) ) ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "unmount" , phase = phase , ) == True ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "delete" , phase = phase , ) == True ) assert ( libcore . 
36;91;2;( ) : try : if pos . target_utils . helper . check_pos_exit ( ) == True : assert pos . target_utils . pos_bring_up ( data_dict = pos . data_dict ) == True assert pos . cli . reset_devel ( ) [ 0 ] == True assert pos . target_utils . pci_rescan ( ) == True assert pos . cli . list_device ( ) [ 0 ] == True assert ( pos . cli . create_array ( array_name = "array1" , data = pos . cli . dev_type [ "SSD" ] 
37;88;2;, phase = phase , ) == True ) logger . info ( "Lock status : acquire {}" . format ( target . cli . lock . acquire ( ) ) ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "unmount" , phase = phase , ) == True ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "delete" , phase = phase , ) == True ) 
38;84;6;] phase_time = Time start_time = time . time ( ) assert ( libcore . subsystem_module ( target = target , client = client , data_set = data_set , config_dict = test_dict , action = "create" , phase = phase , ) == True ) logger . info ( "Lock status : acquire {}" . format ( target . cli . lock . acquire ( ) ) ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = 
39;78;2;) pattern_data = "0x{}" . format ( pattern_data ) bs = test_dict [ "phase" ] [ phase ] [ "io" ] [ "fio" ] [ "bs" ] iod = test_dict [ "phase" ] [ phase ] [ "io" ] [ "fio" ] [ "iodepth" ] assert ( client . fio_generic_runner ( devices = fio_device , fio_user_data = ( "fio  --name=fio_write --rw=write --size={} --ioengine=libaio" " --direct=1 --iodepth={} --bs={} --numjobs=1 --offset=0" " --verify=pattern --verify_pattern={} --do_verify=1" " --verify_dump=1 --verify_fatal=1 --continue_on_error=none" " --group_reporting" . format ( fio_size , iod , bs , pattern_data ) ) , json_out = 
40;77;2;, phase = phase , ) == True ) logger . info ( "Lock status : release {}" . format ( target . cli . lock . release ( ) ) ) except Exception as e : logger . error ( "Failed due to {}" . format ( e ) ) logger . error ( "Failed test case name : {}" . format ( sys . _getframe ( ) . f_code . co_name ) ) logger . error ( "Failed test stage : {}" . format ( phase + 1 ) ) raise 
41;76;2;. format ( volumename , arrayname ) cli_error , jout = self . run_cli_command ( cmd , command_type = "qos" ) if cli_error == True : if jout [ "status_code" ] == 0 : return cli_error , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( "failed due to {}" . format ( e ) ) return False , jout def 
42;76;2;. format ( array_name ) cli_error , jout = self . run_cli_command ( cmd , "wbt" ) if cli_error == True : if jout [ "status_code" ] == 0 : logger . info ( jout [ "description" ] ) return True , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( e ) return False , jout def 
43;76;7;try : if pos . target_utils . helper . check_pos_exit ( ) == True : assert pos . target_utils . pos_bring_up ( data_dict = pos . data_dict ) == True assert pos . cli . reset_devel ( ) [ 0 ] == True assert pos . cli . scan_device ( ) [ 0 ] == True assert pos . cli . list_device ( ) [ 0 ] == True system_disks = pos . cli . system_disks 
44;75;2;, ) [ 0 ] == True ) current_time = time . time ( ) running_time = current_time - start_time if running_time >= phase_time : break except Exception as e : logger . error ( "Failed due to {}" . format ( e ) ) logger . error ( "Failed test case name : {}" . format ( sys . _getframe ( ) . f_code . co_name ) ) logger . error ( "Failed test stage : {}" . format ( phase + 1 ) ) raise 
45;75;4;in ss ] assert ( pos . target_utils . mount_volume_multiple ( array_name = array_name , volume_list = pos . cli . vols , nqn_list = ss_list ) == True ) for ss in pos . target_utils . ss_temp_list : assert ( pos . client . nvme_connect ( ss , pos . target_utils . helper . ip_addr [ 0 ] , "1158" ) == True ) assert pos . client . nvme_list ( ) == True 
46;74;2;array_name ) cli_error , out = self . run_cli_command ( cmd , command_type = "array" ) if cli_error == True : status_code = out [ "status_code" ] if status_code == 0 : return True , out else : raise Exception ( out [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( "command execution failed with exception {}" . format ( e ) ) return False , out def 
47;74;2;. format ( devicename ) cli_error , jout = self . run_cli_command ( cmd , command_type = "device" ) if cli_error == True : if jout [ "status_code" ] == 0 : return cli_error , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( "failed due to {}" . format ( e ) ) return False , jout def 
48;73;6;data_dict = pos . data_dict assert pos . target_utils . pos_bring_up ( data_dict = data_dict ) == True yield pos def teardown_function ( ) : logger . info ( "========== TEAR DOWN AFTER TEST =========" ) assert pos . target_utils . helper . check_system_memory ( ) == True if pos . client . ctrlr_list ( ) [ 1 ] is not None : assert pos . client . nvme_disconnect ( pos . target_utils . ss_temp_list ) == True 
49;72;3;) cli_error , jout = self . run_cli_command ( cmd , "wbt" ) if cli_error == True : if jout [ "status_code" ] == 0 : logger . info ( jout [ "description" ] ) return True , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( e ) return False , jout def 
50;72;3;== True ) assert ( pos . client . nvme_connect ( pos . target_utils . ss_temp_list [ 0 ] , pos . target_utils . helper . ip_addr [ 0 ] , "1158" , ) == True ) assert pos . client . nvme_list ( ) == True assert ( pos . client . fio_generic_runner ( pos . client . nvme_list_out , fio_user_data = "fio --name=sequential_write --ioengine=libaio --rw=write --iodepth=64 --direct=1 --numjobs=1 --bs=128k --time_based --runtime=10" , ) [ 0 ] == True ) 
51;72;6;assert ( pos . target_utils . mount_volume_multiple ( array_name = array_name , volume_list = pos . cli . vols , nqn_list = ss_list ) == True ) for ss in pos . target_utils . ss_temp_list : assert ( pos . client . nvme_connect ( ss , pos . target_utils . helper . ip_addr [ 0 ] , "1158" ) == True ) assert pos . client . nvme_list ( ) == True 
52;71;2;array_name ) cli_error , jout = self . run_cli_command ( cmd , command_type = "volume" ) if cli_error == True : if jout [ "status_code" ] == 0 : return cli_error , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( "failed due to {}" . format ( e ) ) return False , jout def 
53;70;2;else : for array in array_list : if self . name == array : assert self . cli . info_array ( array_name = self . name ) [ 0 ] == True state = self . cli . array_info [ self . name ] [ "state" ] . lower ( ) situation = self . cli . array_info [ self . name ] [ "situation" ] . lower ( ) 
54;70;3;) cli_error , jout = self . run_cli_command ( cmd , command_type = "device" ) if cli_error == True : if jout [ "status_code" ] == 0 : return cli_error , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( "failed due to {}" . format ( e ) ) return False , jout def 
55;70;3;) cli_error , jout = self . run_cli_command ( cmd , command_type = "qos" ) if cli_error == True : if jout [ "status_code" ] == 0 : return cli_error , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( "failed due to {}" . format ( e ) ) return False , jout def 
56;70;5;) cli_error , jout = self . run_cli_command ( cmd , command_type = "volume" ) if cli_error == True : if jout [ "status_code" ] == 0 : return cli_error , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( "failed due to {}" . format ( e ) ) return False , jout def 
57;70;2;cli_error , jout = self . run_cli_command ( command , "devel" ) if cli_error == True : if jout [ "status_code" ] == 0 : logger . info ( jout [ "description" ] ) return True , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( e ) return False , jout 
58;69;2;cli_error , jout = self . run_cli_command ( cmd , command_type = "system" ) if cli_error == True : if jout [ "status_code" ] == 0 : return True , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( "failed due to {}" . format ( e ) ) return False , jout def 
59;69;2;cli_error , jout = self . run_cli_command ( cmd , command_type = "array" ) if cli_error == True : if jout [ "status_code" ] == 0 : return cli_error , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( "failed due to {}" . format ( e ) ) return False , jout def 
60;69;2;cli_error , jout = self . run_cli_command ( cmd , command_type = "array" ) if cli_error == True : if jout [ "status_code" ] == 0 : return True , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( "failed due to {}" . format ( e ) ) return False , jout def 
61;69;4;cli_error , jout = self . run_cli_command ( cmd , command_type = "device" ) if cli_error == True : if jout [ "status_code" ] == 0 : return cli_error , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( "failed due to {}" . format ( e ) ) return False , jout def 
62;69;4;cli_error , jout = self . run_cli_command ( cmd , command_type = "logger" ) if cli_error == True : if jout [ "status_code" ] == 0 : return cli_error , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( "failed due to {}" . format ( e ) ) return False , jout def 
63;69;2;cli_error , jout = self . run_cli_command ( cmd , command_type = "telemetry" ) if cli_error == True : if jout [ "status_code" ] == 0 : return cli_error , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( "failed due to {}" . format ( e ) ) return False , jout def 
64;69;2;pattern_data = target . cli . helper . generate_pattern ( 8 ) pattern_data = "0x{}" . format ( pattern_data ) bs = test_dict [ "phase" ] [ phase ] [ "io" ] [ "fio" ] [ "bs" ] iod = test_dict [ "phase" ] [ phase ] [ "io" ] [ "fio" ] [ "iodepth" ] assert ( client . fio_generic_runner ( devices = fio_device , fio_user_data = ( 
65;69;4;logger . info ( "Lock status : acquire {}" . format ( target . cli . lock . acquire ( ) ) ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "unmount" , phase = phase , ) == True ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = 
66;68;3;for array in array_list : if self . name == array : assert self . cli . info_array ( array_name = self . name ) [ 0 ] == True state = self . cli . array_info [ self . name ] [ "state" ] . lower ( ) situation = self . cli . array_info [ self . name ] [ "situation" ] . lower ( ) 
67;68;2;) assert target . cli . info_array ( target . cli . array_name ) [ 0 ] == True num_data_disks = len ( target . cli . array_info [ target . cli . array_name ] [ "data_list" ] ) stripe_size_for_writing = num_data_disks * 256 * 1024 logger . info ( "Lock status : release {}" . format ( target . cli . lock . release ( ) ) ) fio_size = stripe_size_for_writing 
68;68;4;assert pos . target_utils . pos_bring_up ( data_dict = data_dict ) == True yield pos def teardown_function ( ) : logger . info ( "========== TEAR DOWN AFTER TEST =========" ) assert pos . target_utils . helper . check_system_memory ( ) == True if pos . client . ctrlr_list ( ) [ 1 ] is not None : assert pos . client . nvme_disconnect ( pos . target_utils . ss_temp_list ) == True 
69;67;2;) : try : if pos . target_utils . helper . check_pos_exit ( ) == True : assert pos . target_utils . pos_bring_up ( data_dict = pos . data_dict ) == True assert pos . cli . list_array ( ) [ 0 ] == True for index , array in enumerate ( list ( pos . cli . array_dict . keys ( ) ) ) : assert 
70;66;2;] : logger . info ( "Rebuilding was completed before the function was executed." ) self . state [ "next" ] = state self . situation [ "next" ] = situation logger . info ( "--- ARRAY NAME : {}--- OPERATION : {} ---- CHECK ARRAY STATE : PASS (EXPECTED : {}/{}, ACTUAL : {}/{}) -------" . format ( self . name , self . func [ "name" ] , self . state [ "next" ] , self . situation [ "next" ] , state , situation , ) ) return True elif 
71;65;3;: logger . info ( "Rebuilding was completed before the function was executed." ) self . state [ "next" ] = state self . situation [ "next" ] = situation logger . info ( "--- ARRAY NAME : {}--- OPERATION : {} ---- CHECK ARRAY STATE : PASS (EXPECTED : {}/{}, ACTUAL : {}/{}) -------" . format ( self . name , self . func [ "name" ] , self . state [ "next" ] , self . situation [ "next" ] , state , situation , ) ) return True elif 
72;65;2;) cli_error , jout = self . run_cli_command ( cmd , command_type = "subsystem" ) if cli_error == True : if jout [ "status_code" ] == 0 : return cli_error , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( e ) return False , jout def 
73;64;4;if pos . target_utils . helper . check_pos_exit ( ) == True : assert pos . target_utils . pos_bring_up ( data_dict = pos . data_dict ) == True assert pos . cli . reset_devel ( ) [ 0 ] == True assert pos . target_utils . pci_rescan ( ) == True assert pos . cli . list_device ( ) [ 0 ] == True 
74;63;2;) self . state [ "next" ] = state self . situation [ "next" ] = situation logger . info ( "--- ARRAY NAME : {}--- OPERATION : {} ---- CHECK ARRAY STATE : PASS (EXPECTED : {}/{}, ACTUAL : {}/{}) -------" . format ( self . name , self . func [ "name" ] , self . state [ "next" ] , self . situation [ "next" ] , state , situation , ) ) return True elif self . situation [ 
75;63;3;assert ( pos . cli . create_array ( write_buffer = "uram0" , data = data_disk_list , spare = None , raid_type = raid_type , array_name = array_name , ) [ 0 ] == True ) assert pos . cli . mount_array ( array_name = array_name , write_back = False ) [ 0 ] == True assert ( pos . cli . create_volume ( 
76;62;2;import logger from pos import POS logger = logger . get_logger ( __name__ ) @ pytest . fixture ( scope = "session" , autouse = True ) def setup_module ( ) : global pos , raid_type , data_dict , data_store pos = POS ( ) data_store = { } data_dict = pos . data_dict data_dict [ "array" ] [ "phase" ] = 
77;60;3;, command_type = "system" ) if cli_error == True : if jout [ "status_code" ] == 0 : return True , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( "failed due to {}" . format ( e ) ) return False , jout def 
78;60;2;) if out [ 0 ] == True : if out [ 1 ] [ "output" ] [ "Response" ] [ "result" ] [ "status" ] [ "code" ] == 0 : flag = True else : flag = False else : logger . warning ( "No array found in the config" ) return False , out [ 1 ] if flag == True : 
79;60;5;) if cli_error == True : if jout [ "status_code" ] == 0 : logger . info ( jout [ "description" ] ) return True , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( e ) return False , jout def 
80;60;3;import pytest , json , sys , os , time , random , codecs , re , datetime from random import randint import logger as logger import composable . composable_core as libcore logger = logger . get_logger ( __name__ ) dir_path = os . path . dirname ( os . path . realpath ( __file__ ) ) with open ( 
81;59;3;) self . state [ "next" ] = state self . situation [ "next" ] = situation logger . info ( "--- ARRAY NAME : {}--- OPERATION : {} ---- CHECK ARRAY STATE : PASS (EXPECTED : {}/{}, ACTUAL : {}/{}) -------" . format ( self . name , self . func [ "name" ] , self . state [ "next" ] , self . situation [ "next" ] , state , situation , ) ) return True elif 
82;59;5;) if cli_error == True : if jout [ "status_code" ] == 0 : logger . info ( jout [ "description" ] ) return True , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( e ) return False , jout 
83;58;2;== self . situation [ "current" ] and self . data_dict [ "array" ] [ "num_array" ] > 1 ) : logger . info ( "Skip the add spare because array has full data device" ) assert ( update_next_status ( state = self . state [ "current" ] , situation = self . situation [ "current" ] , expected = True , ) == True ) elif 
84;58;5;) self . state [ "next" ] = state self . situation [ "next" ] = situation logger . info ( "--- ARRAY NAME : {}--- OPERATION : {} ---- CHECK ARRAY STATE : PASS (EXPECTED : {}/{}, ACTUAL : {}/{}) -------" . format ( self . name , self . func [ "name" ] , self . state [ "next" ] , self . situation [ "next" ] , state , situation , ) ) return True 
85;58;7;, phase = phase , ) == True ) assert ( libcore . volume_module ( target = target , data_set = data_set , config_dict = test_dict , action = "mount" , phase = phase , ) == True ) logger . info ( "Lock status : release {}" . format ( target . cli . lock . release ( ) ) ) 
86;58;2;logger . info ( "Lock status : acquire {}" . format ( target . cli . lock . acquire ( ) ) ) pattern_data = target . cli . helper . generate_pattern ( 8 ) logger . info ( "Lock status : release {}" . format ( target . cli . lock . release ( ) ) ) pattern_data = "0x{}" . format ( pattern_data ) 
87;58;2;) pattern_data = "0x{}" . format ( pattern_data ) bs = test_dict [ "phase" ] [ phase ] [ "io" ] [ "fio" ] [ "bs" ] iod = test_dict [ "phase" ] [ phase ] [ "io" ] [ "fio" ] [ "iodepth" ] assert ( client . fio_generic_runner ( devices = fio_device , fio_user_data = ( 
88;57;3;== True yield pos def teardown_function ( ) : logger . info ( "========== TEAR DOWN AFTER TEST =========" ) assert pos . target_utils . helper . check_system_memory ( ) == True if pos . client . ctrlr_list ( ) [ 1 ] is not None : assert pos . client . nvme_disconnect ( pos . target_utils . ss_temp_list ) == True 
89;56;5;) if cli_error == True : if jout [ "status_code" ] == 0 : return True , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( "failed due to {}" . format ( e ) ) return False , jout def 
90;56;20;) if cli_error == True : if jout [ "status_code" ] == 0 : return cli_error , jout else : raise Exception ( jout [ "description" ] ) else : raise Exception ( "CLI Error" ) except Exception as e : logger . error ( "failed due to {}" . format ( e ) ) return False , jout def 
91;55;2;for array in array_list : assert self . cli . mount_array ( array_name = array ) [ 0 ] == True assert self . cli . list_volume ( array_name = array ) [ 0 ] == True if len ( self . cli . vols ) == 0 : logger . info ( "No volumes found" ) 
92;55;2;) assert pos . cli . list_volume ( array_name = array ) [ 0 ] == True assert ( pos . target_utils . mount_volume_multiple ( array_name = array , volume_list = pos . cli . vols , nqn_list = [ pos . target_utils . ss_temp_list [ index ] ] , ) == True ) for 
93;55;2;yield pos def teardown_function ( ) : logger . info ( "========== TEAR DOWN AFTER TEST =========" ) assert pos . target_utils . helper . check_system_memory ( ) == True if pos . client . ctrlr_list ( ) [ 1 ] is not None : assert pos . client . nvme_disconnect ( pos . target_utils . ss_temp_list ) == True 
94;54;4;] , pos . target_utils . helper . ip_addr [ 0 ] , "1158" , ) == True ) assert pos . client . nvme_list ( ) == True assert ( pos . client . fio_generic_runner ( pos . client . nvme_list_out , fio_user_data = "fio --name=sequential_write --ioengine=libaio --rw=write --iodepth=64 --direct=1 --numjobs=1 --bs=128k --time_based --runtime=10" , ) [ 0 ] == True ) 
95;54;4;, array_name = array_name , size = "2000gb" ) [ 0 ] == True ) assert pos . target_utils . get_subsystems_list ( ) == True assert pos . cli . list_volume ( array_name = array_name ) [ 0 ] == True ss_list = [ ss for ss in pos . target_utils . ss_temp_list if 
96;53;3;( target = None , client = None , phase = None , data_set = None , Time = None ) : try : if ( target == None or client == None or phase == None or data_set == None or Time == None ) : raise AssertionError test_dict = tc_dict [ 
97;53;2;assert pos . cli . list_array ( ) [ 0 ] == True array_list = list ( pos . cli . array_dict . keys ( ) ) if len ( array_list ) == 0 : logger . info ( "No array found in the config" ) else : for array in array_list : assert pos . cli . 
98;52;2;: assert ( update_next_status ( state = "offline" , situation = "default" , expected = True ) == True ) else : assert ( update_next_status ( state = self . state [ "current" ] , situation = self . situation [ "current" ] , expected = False , ) == True ) 
99;52;2;, test_dict [ "phase" ] [ phase ] [ "io" ] [ "fio" ] [ "size" ] , test_dict [ "phase" ] [ phase ] [ "io" ] [ "fio" ] [ "iodepth" ] , test_dict [ "phase" ] [ phase ] [ "io" ] [ "fio" ] [ "bs" ] , 
100;52;2;== True ) except Exception as e : logger . error ( "Failed due to {}" . format ( e ) ) logger . error ( "Failed test case name : {}" . format ( sys . _getframe ( ) . f_code . co_name ) ) logger . error ( "Failed test stage : {}" . format ( phase + 1 ) ) raise 
101;52;2;== True assert self . cli . list_array ( ) [ 0 ] == True array_list = list ( self . cli . array_dict . keys ( ) ) if len ( array_list ) == 0 : logger . info ( "No Array Present in the config" ) return False else : for array in array_list : 
102;52;4;, data = data_disk_list , spare = None , raid_type = raid_type , array_name = array_name , ) [ 0 ] == True ) assert pos . cli . mount_array ( array_name = array_name , write_back = False ) [ 0 ] == True assert ( pos . cli . create_volume ( 
103;52;2;data_disk_list = [ system_disks . pop ( 0 ) for i in range ( nr_data_drives ) ] assert ( pos . cli . create_array ( write_buffer = uram , data = data_disk_list , spare = None , raid_type = raid_type , array_name = array_name , ) [ 0 ] == True ) 
104;51;2;) except Exception as e : logger . error ( "Failed due to {}" . format ( e ) ) logger . error ( "Failed test case name : {}" . format ( sys . _getframe ( ) . f_code . co_name ) ) logger . error ( "Failed test stage : {}" . format ( phase + 1 ) ) raise def 
105;51;2;for id , array_name in enumerate ( ( array_name1 , array_name2 ) ) : assert pos . cli . info_array ( array_name = array_name ) [ 0 ] == True array_size = int ( pos . cli . array_info [ array_name ] . get ( "size" ) ) vol_size = f 
106;50;2;: assert ( update_next_status ( state = "busy" , situation = "rebuilding" , expected = True ) == True ) self . device [ "rebuild" ] = "" . join ( self . device [ "spare" ] [ - 1 ] ) else : assert ( update_next_status ( state = 
107;50;3;except Exception as e : logger . error ( "Failed due to {}" . format ( e ) ) logger . error ( "Failed test case name : {}" . format ( sys . _getframe ( ) . f_code . co_name ) ) logger . error ( "Failed test stage : {}" . format ( phase + 1 ) ) raise def 
108;50;4;) except Exception as e : logger . error ( "Failed due to {}" . format ( e ) ) logger . error ( "Failed test case name : {}" . format ( sys . _getframe ( ) . f_code . co_name ) ) logger . error ( "Failed test stage : {}" . format ( phase + 1 ) ) raise 
